{"name": "笔记查询测试：Token为空（未登录）", "status": "failed", "statusDetails": {"message": "AssertionError: 笔记请求异常：状态码401\nassert 401 == 200\n +  where 401 = <Response [401]>.status_code", "trace": "self = <test_send_code.TestNoteDetail object at 0x000001E91FB89410>\nreq_session = <requests.sessions.Session object at 0x000001E91FC342D0>\nget_login_token = 'gZRxuOuEiLQOcG1VZadLJrn5vhPwyGk08u7pJMJdOs4Ns4tEUFtKdCPEFB4GnjEkjSoOdxSo0LjU1NuYJNHlfAaFXlIFTAnwBm9DgGkWjZwINIMWpnZa2MjOXprbhrhT'\ntoken_type = '', note_id = 1964771849623568408, expect_success = False, expect_msg = 'Token为空', scene_desc = 'Token为空（未登录）'\n\n    @allure.story(\"笔记查询场景（参数化批量测试：正常+失败）\")\n    @allure.title(\"笔记查询测试：{scene_desc}\")\n    @pytest.mark.parametrize(\"token_type, note_id, expect_success, expect_msg, scene_desc\", note_detail_param_data)\n    def test_note_detail_parametrize(\n            self, req_session, get_login_token, token_type, note_id, expect_success, expect_msg, scene_desc\n    ):\n        \"\"\"\n        参数化测试：覆盖笔记查询的正常场景+4种失败场景\n        依赖 get_login_token Fixture：直接使用有效Token，无需重复登录\n        \"\"\"\n        # 1. 处理Token（区分“有效/无效/空”场景）\n        if token_type == \"valid_token\":\n            token = \"Bearer \" + get_login_token  # 使用Fixture的有效Token\n        elif token_type == \"invalid_token\":\n            token = \"Bearer fake_token_123456\"  # 伪造无效Token\n        else:  # token_type == \"\"\n            token = \"Bearer \"  # Token为空\n    \n        # 2. 接口信息（请求头+参数）\n        note_url = f\"{BASE_URL}{NOTE_DETAIL_URL}\"\n        headers = {\n            \"Authorization\": token,  # 携带Token（有效/无效/空）\n            \"Content-Type\": \"application/json\"\n        }\n        note_payload = {\"id\": note_id}\n    \n        # 3. 发送请求\n        with allure.step(f\"发送笔记查询请求：{scene_desc}\"):\n            response = req_session.post(url=note_url, json=note_payload, headers=headers)\n            print(f\"\\n【{scene_desc}】笔记响应: {response.text}\")\n    \n        # 4. 断言\n        with allure.step(\"验证HTTP状态码为200\"):\n>           assert response.status_code == 200, f\"笔记请求异常：状态码{response.status_code}\"\nE           AssertionError: 笔记请求异常：状态码401\nE           assert 401 == 200\nE            +  where 401 = <Response [401]>.status_code\n\ntest_send_code.py:209: AssertionError"}, "description": "\n        参数化测试：覆盖笔记查询的正常场景+4种失败场景\n        依赖 get_login_token Fixture：直接使用有效Token，无需重复登录\n        ", "steps": [{"name": "发送笔记查询请求：Token为空（未登录）", "status": "passed", "start": 1757472940835, "stop": 1757472940837}, {"name": "验证HTTP状态码为200", "status": "failed", "statusDetails": {"message": "AssertionError: 笔记请求异常：状态码401\nassert 401 == 200\n +  where 401 = <Response [401]>.status_code\n", "trace": "  File \"C:\\Users\\33042\\Desktop\\api_test_project\\test_send_code.py\", line 209, in test_note_detail_parametrize\n    assert response.status_code == 200, f\"笔记请求异常：状态码{response.status_code}\"\n"}, "start": 1757472940837, "stop": 1757472940837}], "attachments": [{"name": "stdout", "source": "df6e971b-ccd0-4a51-aba5-8f425fe4b6be-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "token_type", "value": "''"}, {"name": "note_id", "value": "1964771849623568408"}, {"name": "expect_success", "value": "False"}, {"name": "expect_msg", "value": "'Token为空'"}, {"name": "scene_desc", "value": "'Token为空（未登录）'"}], "start": 1757472940835, "stop": 1757472940837, "uuid": "4af3827f-b2e3-47c0-856d-8657501520e0", "historyId": "1e1a1b5ecd9d77003c98e899640701b5", "testCaseId": "fd2a8959df1d9b091186df995fa0290d", "fullName": "test_send_code.TestNoteDetail#test_note_detail_parametrize", "labels": [{"name": "story", "value": "笔记查询场景（参数化批量测试：正常+失败）"}, {"name": "feature", "value": "3. 笔记详情查询接口"}, {"name": "suite", "value": "test_send_code"}, {"name": "subSuite", "value": "TestNoteDetail"}, {"name": "host", "value": "2001TXY-HP"}, {"name": "thread", "value": "35256-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_send_code"}], "titlePath": ["test_send_code.py", "TestNoteDetail"]}